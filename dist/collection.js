(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Collection"] = factory();
	else
		root["Collection"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Collection = exports.Collection = function () {\n    function Collection() {\n        var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        _classCallCheck(this, Collection);\n\n        this.items = Collection.getArraybleItems(items);\n    }\n\n    _createClass(Collection, [{\n        key: 'all',\n        value: function all() {\n            var recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            if (recursive && Array.isArray(this.items)) {\n                return this.items.map(function (item) {\n                    if (item instanceof Collection) {\n                        return item.all(true);\n                    }\n\n                    return item;\n                });\n            }\n\n            return this.items;\n        }\n    }, {\n        key: 'avg',\n        value: function avg() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var count = this.count();\n            if (count) {\n                return this.sum(callback) / count;\n            }\n\n            return this;\n        }\n    }, {\n        key: 'average',\n        value: function average() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            return this.avg(callback);\n        }\n    }, {\n        key: 'chunk',\n        value: function chunk(size) {\n            if (size <= 0) {\n                return new Collection();\n            }\n\n            return new Collection(this.all().reduce(function (a, b, i, g) {\n                if (!(i % size)) {\n                    return a.concat([g.slice(i, i + size)]);\n                }\n\n                return a;\n            }, []));\n        }\n    }, {\n        key: 'collapse',\n        value: function collapse() {\n            var results = [];\n\n            this.all().forEach(function (values) {\n                if (values instanceof Collection) {\n                    values = values.all();\n                } else if (!Array.isArray(values)) {\n                    return;\n                }\n\n                results = [].concat(_toConsumableArray(results), _toConsumableArray(values));\n            });\n\n            return new Collection(results);\n        }\n    }, {\n        key: 'combine',\n        value: function combine(values) {\n            var newArray = {};\n            this.all().forEach(function (item, key) {\n                newArray[item] = values[key];\n            });\n\n            return new Collection(newArray);\n        }\n    }, {\n        key: 'contains',\n        value: function contains() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            if (typeof callback !== 'function' && callback !== null) {\n                return this.items.some(function (item) {\n                    if (strict) {\n                        return item === callback;\n                    }\n\n                    // eslint-disable-next-line eqeqeq\n                    return item == callback;\n                });\n            }\n\n            return this.items.some(function (item, key) {\n                return callback(item, key);\n            });\n        }\n    }, {\n        key: 'count',\n        value: function count() {\n            if (this.isObject()) {\n                return Object.keys(this.all()).length;\n            }\n\n            return this.all().length;\n        }\n    }, {\n        key: 'diff',\n        value: function diff(values) {\n            values = new Collection(values);\n\n            return this.reject(function (item) {\n                return values.contains(item);\n            });\n        }\n    }, {\n        key: 'diffKeys',\n        value: function diffKeys(values) {\n            values = new Collection(values);\n\n            return this.reject(function (item) {\n                var _Object$keys = Object.keys(item),\n                    _Object$keys2 = _slicedToArray(_Object$keys, 1),\n                    itemKey = _Object$keys2[0];\n\n                return values.contains(function (value) {\n                    var _Object$keys3 = Object.keys(value),\n                        _Object$keys4 = _slicedToArray(_Object$keys3, 1),\n                        key = _Object$keys4[0];\n\n                    return itemKey === key;\n                });\n            });\n        }\n    }, {\n        key: 'each',\n        value: function each(callback) {\n            return this.all().forEach(callback);\n        }\n    }, {\n        key: 'every',\n        value: function every(callback) {\n            return this.all().every(callback);\n        }\n    }, {\n        key: 'except',\n        value: function except() {\n            for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {\n                keys[_key] = arguments[_key];\n            }\n\n            if (!Array.isArray(this.all())) {\n                keys = new Collection(keys);\n\n                return new Collection(Object.entries(this.all()).filter(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 1),\n                        key = _ref2[0];\n\n                    return !keys.contains(key);\n                }).reduce(function (result, _ref3) {\n                    var _ref4 = _slicedToArray(_ref3, 2),\n                        key = _ref4[0],\n                        value = _ref4[1];\n\n                    return Object.assign({}, result, _defineProperty({}, key, value));\n                }, {}));\n            }\n\n            return null;\n        }\n    }, {\n        key: 'filter',\n        value: function filter(callback) {\n            return new Collection(this.all().filter(callback));\n        }\n    }, {\n        key: 'first',\n        value: function first() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (this.items.length === 0) {\n                return null;\n            }\n\n            if (typeof callback === 'function') {\n                var possibleItems = this.all().filter(function (item, key) {\n                    return callback(item, key);\n                });\n\n                if (possibleItems.length > 0) {\n                    return possibleItems[0];\n                }\n            }\n\n            return this.items[0];\n        }\n    }, {\n        key: 'flatten',\n        value: function flatten() {\n            var _ref5;\n\n            var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var flattened = new Collection((_ref5 = []).concat.apply(_ref5, _toConsumableArray(this.all())));\n\n            if (!depth || !flattened.contains(Array.isArray)) {\n                return flattened;\n            }\n\n            return flattened.flatten(true);\n        }\n    }, {\n        key: 'flip',\n        value: function flip() {\n            var _this = this;\n\n            if (!Array.isArray(this.all())) {\n                var o = Object.keys(this.all()).reduce(function (obj, key) {\n                    return Object.assign({}, obj, _defineProperty({}, _this.all()[key], key));\n                }, {});\n\n                return new Collection(o);\n            }\n\n            return this.map(function (item) {\n                return Object.keys(item).reduce(function (obj, key) {\n                    return Object.assign({}, obj, _defineProperty({}, item[key], key));\n                }, []);\n            });\n        }\n    }, {\n        key: 'forget',\n        value: function forget(key) {\n            delete this.all()[key];\n\n            return this;\n        }\n    }, {\n        key: 'get',\n        value: function get(key) {\n            return this.all()[key] || null;\n        }\n    }, {\n        key: 'has',\n        value: function has(key) {\n            if (!Array.isArray(this.all())) {\n                return this.all().hasOwnProperty(key);\n            }\n\n            return !!~this.all().indexOf(key);\n        }\n    }, {\n        key: 'implode',\n        value: function implode(value) {\n            var glue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var first = this.first();\n\n            if ((typeof first === 'undefined' ? 'undefined' : _typeof(first)) === 'object') {\n                return this.pluck(value).all().join(glue);\n            }\n\n            return this.all().join(value);\n        }\n    }, {\n        key: 'isEmpty',\n        value: function isEmpty() {\n            return this.count() === 0;\n        }\n    }, {\n        key: 'isNotEmpty',\n        value: function isNotEmpty() {\n            return !this.isEmpty();\n        }\n    }, {\n        key: 'isObject',\n        value: function isObject() {\n            return _typeof(this.all()) === 'object';\n        }\n    }, {\n        key: 'keys',\n        value: function keys() {\n            return new Collection(Object.keys(this.all()));\n        }\n    }, {\n        key: 'last',\n        value: function last() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (typeof callback === 'function') {\n                return this.reverse().first(callback);\n            }\n\n            return this.items[this.count() - 1];\n        }\n    }, {\n        key: 'map',\n        value: function map(callback) {\n            return new Collection(this.all().map(callback));\n        }\n    }, {\n        key: 'max',\n        value: function max() {\n            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var start = this.first();\n\n            if (key) {\n                start = start[key];\n            }\n\n            return this.filter(function (value) {\n                if (key) {\n                    return value[key] !== null;\n                }\n\n                return value !== null;\n            }).reduce(function (result, item) {\n                if (key) {\n                    item = item[key];\n                }\n\n                return result === null || item > result ? item : result;\n            }, start);\n        }\n    }, {\n        key: 'median',\n        value: function median() {\n            var _this2 = this;\n\n            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var count = this.count();\n\n            if (count === 0) {\n                return null;\n            }\n\n            var values = this.pipe(function () {\n                return key ? _this2.pluck(key) : _this2;\n            }).sort().values();\n\n            var middle = parseInt(count / 2);\n\n            if (count % 2) {\n                return values.get(middle);\n            }\n\n            return new Collection([values.get(middle - 1), values.get(middle)]).average();\n        }\n    }, {\n        key: 'merge',\n        value: function merge(objects) {\n            return this.map(function (item, index) {\n                return Object.assign({}, item, objects[index]);\n            });\n        }\n    }, {\n        key: 'min',\n        value: function min() {\n            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            var start = this.first();\n\n            if (key) {\n                start = start[key];\n            }\n\n            return this.filter(function (value) {\n                if (key) {\n                    return value[key] !== null;\n                }\n\n                return value !== null;\n            }).reduce(function (result, item) {\n                if (key) {\n                    item = item[key];\n                }\n\n                return result === null || item < result ? item : result;\n            }, start);\n        }\n    }, {\n        key: 'mode',\n        value: function mode() {\n            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (this.isEmpty()) {\n                return null;\n            }\n\n            var collection = key ? this.pluck(key) : this;\n            var numMapping = {};\n            var greatestFreq = 0;\n            var mode = null;\n\n            collection.each(function (number) {\n                numMapping[number] = (numMapping[number] || 0) + 1;\n\n                if (greatestFreq < numMapping[number]) {\n                    greatestFreq = numMapping[number];\n                    mode = number;\n                }\n            });\n\n            return +mode;\n        }\n    }, {\n        key: 'nth',\n        value: function nth(step) {\n            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            var newArr = [];\n            var position = 0;\n\n            this.all().forEach(function (item) {\n                if (position % step === offset) {\n                    newArr.push(item);\n                }\n\n                position += 1;\n            });\n\n            return new Collection(newArr);\n        }\n    }, {\n        key: 'only',\n        value: function only() {\n            for (var _len2 = arguments.length, keys = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                keys[_key2] = arguments[_key2];\n            }\n\n            if (!Array.isArray(this.all())) {\n                var obj = {};\n\n                Object.entries(this.all()).forEach(function (_ref6) {\n                    var _ref7 = _slicedToArray(_ref6, 2),\n                        key = _ref7[0],\n                        value = _ref7[1];\n\n                    [].concat(keys).filter(function (objKey) {\n                        return objKey === key;\n                    }).forEach(function (objKey) {\n                        return obj[objKey] = value;\n                    });\n                });\n\n                return new Collection(obj);\n            }\n\n            return null;\n        }\n    }, {\n        key: 'pipe',\n        value: function pipe(callback) {\n            return callback(this);\n        }\n    }, {\n        key: 'pluck',\n        value: function pluck(property) {\n            var keyed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (keyed) {\n                return this.map(function (item) {\n                    var obj = {};\n                    obj[item[keyed]] = item[property];\n\n                    return obj;\n                });\n            }\n\n            return this.map(function (item) {\n                return item[property];\n            });\n        }\n    }, {\n        key: 'pop',\n        value: function pop() {\n            return this.all().pop();\n        }\n    }, {\n        key: 'prepend',\n        value: function prepend(value) {\n            var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (key) {\n                return key.concat(this.all());\n            }\n\n            this.unshift(value);\n\n            return this;\n        }\n    }, {\n        key: 'pull',\n        value: function pull(key) {\n            var pulled = this.get(key);\n            var obj = Object.entries(this.all()).filter(function (_ref8) {\n                var _ref9 = _slicedToArray(_ref8, 1),\n                    objKey = _ref9[0];\n\n                return objKey !== key;\n            }).reduce(function (result, _ref10) {\n                var _ref11 = _slicedToArray(_ref10, 2),\n                    objKey = _ref11[0],\n                    value = _ref11[1];\n\n                return Object.assign({}, result, _defineProperty({}, objKey, value));\n            }, {});\n\n            if (Object.keys(obj).length > 0) {\n                this.items = obj;\n\n                return pulled;\n            }\n\n            return null;\n        }\n    }, {\n        key: 'put',\n        value: function put(key, value) {\n            if (this.isObject()) {\n                this.all()[key] = value;\n\n                return new Collection(this.all());\n            }\n\n            return false;\n        }\n    }, {\n        key: 'push',\n        value: function push(item) {\n            this.all().push(item);\n\n            return this;\n        }\n    }, {\n        key: 'reduce',\n        value: function reduce(callback) {\n            var initial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            return this.all().reduce(callback, initial);\n        }\n    }, {\n        key: 'reject',\n        value: function reject(callback) {\n            return new Collection(this.all().filter(function (item, key) {\n                return !callback(item, key);\n            }));\n        }\n    }, {\n        key: 'reverse',\n        value: function reverse() {\n            return new Collection(this.all().reverse());\n        }\n    }, {\n        key: 'shift',\n        value: function shift() {\n            return this.all().shift();\n        }\n    }, {\n        key: 'slice',\n        value: function slice(offset) {\n            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            if (length) {\n                return new Collection(this.all().slice(offset, length + offset));\n            }\n\n            return new Collection(this.all().slice(offset));\n        }\n    }, {\n        key: 'sort',\n        value: function sort() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (callback) {\n                return new Collection(this.all().sort(callback));\n            }\n\n            return new Collection(this.all().sort());\n        }\n    }, {\n        key: 'sortDesc',\n        value: function sortDesc() {\n            var sorted = this.sort();\n\n            return new Collection(sorted.all().reverse());\n        }\n    }, {\n        key: 'splice',\n        value: function splice(offset) {\n            var _all;\n\n            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n            // eslint-disable-next-line prefer-rest-params\n            if ([].concat(Array.prototype.slice.call(arguments)).length === 1) {\n                return new Collection(this.all().splice(offset));\n            }\n\n            if (replacement.length === 0) {\n                return new Collection(this.all().splice(offset, length));\n            }\n\n            return new Collection((_all = this.all()).splice.apply(_all, [offset, length].concat(_toConsumableArray(replacement))));\n        }\n    }, {\n        key: 'split',\n        value: function split(numberOfGroups) {\n            if (this.isEmpty()) {\n                return new Collection();\n            }\n\n            var groupSize = Math.ceil(this.count() / numberOfGroups);\n\n            return this.chunk(groupSize);\n        }\n    }, {\n        key: 'sum',\n        value: function sum() {\n            var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (typeof callback === 'function') {\n                return this.all().reduce(function (a, b) {\n                    return a + callback(b);\n                }, 0);\n            }\n\n            if (typeof callback === 'string') {\n                return this.all().reduce(function (a, b) {\n                    if (a.hasOwnProperty(callback) && b.hasOwnProperty(callback)) {\n                        return a[callback] + b[callback];\n                    }\n\n                    return a + b[callback];\n                });\n            }\n\n            return this.all().reduce(function (a, b) {\n                return a + b;\n            }, 0);\n        }\n    }, {\n        key: 'tap',\n        value: function tap(callback) {\n            callback(new Collection(this.all()));\n\n            return this;\n        }\n    }, {\n        key: 'take',\n        value: function take(amount) {\n            if (!amount) {\n                return new Collection();\n            }\n\n            if (amount < 0) {\n                return new Collection(this.all().reverse()).take(-amount);\n            }\n\n            return new Collection(this.all().slice(0, amount));\n        }\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return this.all(true);\n        }\n    }, {\n        key: 'unique',\n        value: function unique() {\n            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (typeof key === 'string') {\n                return this.unique(function (item) {\n                    return item[key];\n                });\n            }\n\n            if (key) {\n                var mappedCollection = new Collection();\n\n                return this.reduce(function (collection, item) {\n                    var mappedItem = key(item);\n                    if (!mappedCollection.has(mappedItem)) {\n                        collection.push(item);\n                        mappedCollection.push(mappedItem);\n                    }\n\n                    return collection;\n                }, new Collection());\n            }\n\n            return this.reduce(function (collection, item) {\n                if (!collection.has(item)) {\n                    collection.push(item);\n                }\n\n                return collection;\n            }, new Collection());\n        }\n    }, {\n        key: 'unshift',\n        value: function unshift() {\n            var _all2;\n\n            return (_all2 = this.all()).unshift.apply(_all2, arguments);\n        }\n    }, {\n        key: 'values',\n        value: function values() {\n            var _this3 = this;\n\n            return this.keys().map(function (key) {\n                return _this3.all()[key];\n            });\n        }\n    }, {\n        key: 'when',\n        value: function when(value, callback) {\n            var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n            if (value) {\n                return callback(this);\n            } else if (defaultValue) {\n                return defaultValue(this);\n            }\n\n            return this;\n        }\n    }, {\n        key: 'where',\n        value: function where(key, value) {\n            // eslint-disable-next-line eqeqeq\n            return this.filter(function (item) {\n                return item[key] == value;\n            });\n        }\n    }, {\n        key: 'whereStrict',\n        value: function whereStrict(key, value) {\n            return this.filter(function (item) {\n                return item[key] === value;\n            });\n        }\n    }, {\n        key: 'whereIn',\n        value: function whereIn(key, values) {\n            return this.filter(function (item) {\n                return new Collection(values).contains(item[key]);\n            });\n        }\n    }, {\n        key: 'whereInStrict',\n        value: function whereInStrict(key, values) {\n            return this.filter(function (item) {\n                return new Collection(values).contains(item[key], true);\n            });\n        }\n    }, {\n        key: 'zip',\n        value: function zip(array) {\n            if (array instanceof Collection) {\n                return this.map(function (item, index) {\n                    return [item, array.get(index)];\n                });\n            }\n\n            return this.map(function (item, index) {\n                return [item, array[index]];\n            });\n        }\n    }], [{\n        key: 'getArraybleItems',\n        value: function getArraybleItems(items) {\n            if (Array.isArray(items)) {\n                return items;\n            }\n\n            if (items instanceof Collection) {\n                return items.all(true);\n            }\n\n            if (typeof items.toArray === 'function') {\n                return items.toArray();\n            }\n\n            if (items instanceof Object) {\n                return items;\n            }\n\n            return [items];\n        }\n    }, {\n        key: 'hasMacro',\n        value: function hasMacro(name) {\n            return Collection.prototype[name] !== undefined;\n        }\n    }, {\n        key: 'macro',\n        value: function macro(name, callback) {\n            if (Collection.prototype[name] !== undefined) {\n                throw new Error('Collection.macro(): This macro name is already defined.');\n            }\n\n            Collection.prototype[name] = function collectionMacroWrapper() {\n                var collection = this;\n\n                for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                    args[_key3] = arguments[_key3];\n                }\n\n                return callback.apply(undefined, [collection].concat(args));\n            };\n        }\n    }, {\n        key: 'times',\n        value: function times(amount, callback) {\n            if (amount < 1) {\n                return new Collection();\n            }\n\n            var _ref12 = [].concat(_toConsumableArray(Array(amount + 1).keys())),\n                times = _ref12.slice(1);\n\n            return new Collection(times).map(callback);\n        }\n    }]);\n\n    return Collection;\n}();\n\nvar collect = exports.collect = function collect(items) {\n    return new Collection(items);\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/collection.js\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/collection.js?");

/***/ })
/******/ ]);
});